package org.bau.parser;

public class StandardLib {

    public static final String TM_MALLOC_INCLUDE =
              "<stddef.h>\n"
            + "<stdint.h>\n";

    public static final String TM_MALLOC =
            "// malloc =============================\n"
            + "#define ASSERT(A)   \n"
            + "// #define ASSERT(A)   do{if(!(A)){printf(\"Assertion %s, line %d\\n\",#A,__LINE__);exit(1);}}while(0)\n"
            + "size_t tmmalloc_nextAllocate = 32 * 1024 * 1024;\n"
            + "int tmmalloc_arenaRemaining = 0;\n"
            + "uint64_t* tmmalloc_arenaStart = 0;\n"
            + "uint64_t tmmalloc_levelBitmap = 0;\n"
            + "int tmmalloc_poolId;\n"
            + "uint64_t tmmalloc_data[256];\n"
            + "uint64_t* tmmalloc_init();\n"
            + "void* tmmalloc(size_t size);\n"
            + "void* tmmalloc_larger(int size, int index0);\n"
            + "void tmfree(void* ptr);\n"
            + "void tmmalloc_insertIntoFreeBlocksMap(uint64_t* block, uint64_t size);\n"
            + "void tmmalloc_removeFromFreeBlocksMap(uint64_t* block, int index);\n"
            + "int tmmalloc_sizeClass(uint64_t size) {\n"
            + "    int log2 = 63 - __builtin_clzll(size);\n"
            + "    int result = 2 * log2 + (int) (((size) << 1 >> log2) ^ 2);\n"
            + "    return result > 63 ? 63 : result;\n"
            + "}\n"
            + "int tmmalloc_sizeClassRoundUp(uint64_t size) {\n"
            + "    int log2 = 63 - __builtin_clzll(size);\n"
            + "    int64_t twoBits = (size >> (log2 - 1)) << (log2 - 1);\n"
            + "    int result = 2 * log2 + (int) ((size << 1 >> log2) ^ 2);\n"
            + "    int64_t mask = (twoBits - (int64_t) size) >> 63;\n"
            + "    return result + (mask & 1);\n"
            + "}\n"
            + "void tmmalloc_insertIntoFreeBlocksMap(uint64_t* block, uint64_t size) {\n"
            + "    int index = tmmalloc_sizeClass(size);\n"
            + "    block[0] = (size << 1) | 1;\n"
            + "    ASSERT(block[0] << 1 >> 32 == 0);\n"
            + "    block[1] = (uint64_t) tmmalloc_data[2 * index];\n"
            + "    block[2] = (uint64_t) &tmmalloc_data[2 * index];\n"
            + "    tmmalloc_data[2 * index] = (uint64_t) (block + 1);\n"
            + "    uint64_t* n = (uint64_t*) block[1];\n"
            + "    n[1] = (uint64_t) (block + 1);\n"
            + "    tmmalloc_levelBitmap |= 1ULL << index;\n"
            + "}\n"
            + "uint64_t* tmmalloc_addMemory() {\n"
            + "    for (int i = 0; i < 10; i++) {\n"
            + "        uint64_t x = (uint64_t) (uintptr_t) malloc(tmmalloc_nextAllocate);\n"
            + "        if (x != 0) {\n"
            + "            tmmalloc_data[tmmalloc_poolId++] = x;\n"
            + "            tmmalloc_insertIntoFreeBlocksMap((uint64_t*) x, (tmmalloc_nextAllocate - 8) >> 3);\n"
            + "            tmmalloc_nextAllocate *= 2;\n"
            + "            return (uint64_t*) x;\n"
            + "        }\n"
            + "        tmmalloc_nextAllocate /= 2;\n"
            + "    }\n"
            + "    printf(\"Out of memory\");\n"
            + "    exit(-1);\n"
            + "}\n"
            + "uint64_t* tmmalloc_init() {\n"
            + "    tmmalloc_levelBitmap = 0;\n"
            + "    tmmalloc_arenaStart = 0;\n"
            + "    tmmalloc_arenaRemaining = 0;\n"
            + "    for (int i = 0; i < 64; i++) {\n"
            + "        uintptr_t x = (uintptr_t) &tmmalloc_data[2 * i];\n"
            + "        tmmalloc_data[2 * i] = (uint64_t) x;\n"
            + "        tmmalloc_data[2 * i + 1] = (uint64_t) x;\n"
            + "    }\n"
            + "    tmmalloc_poolId = 128;\n"
            + "    return (uint64_t*) tmmalloc_addMemory();\n"
            + "}\n"
            + "void tmmalloc_freeAll() {\n"
            + "    while (tmmalloc_poolId > 128) {\n"
            + "        free((uint64_t*) tmmalloc_data[--tmmalloc_poolId]);\n"
            + "    }\n"
            + "}\n"
            + "void* tmmalloc(size_t sizeBytes) {\n"
            + "    if (sizeBytes == 0) return 0;\n"
            + "    // 8 bytes more for metadata; round up, and convert to i64\n"
            + "    uint64_t size = (sizeBytes + 8 + 7) >> 3;  \n"
            + "    if (size < 3) size = 3;\n"
            + "    int index0;\n"
            + "    int result = tmmalloc_sizeClassRoundUp(size);\n"
            + "    index0 = result > 63 ? 63 : result;\n"
            + "    // return tmmalloc_larger(size, index0); \n"
            + "    if ((tmmalloc_levelBitmap & (1ULL << index0)) == 1) {\n"
            + "        return tmmalloc_larger(size, index0);        \n"
            + "    }\n"
            + "    if (size <= 16) {\n"
            + "        if (tmmalloc_arenaRemaining < size) {\n"
            + "            if (tmmalloc_arenaRemaining > 0) {\n"
            + "                ASSERT(tmmalloc_arenaRemaining >= 3);\n"
            + "                tmmalloc_arenaRemaining = 0;\n"
            + "                tmfree(tmmalloc_arenaStart + 1);\n"
            + "            }\n"
            + "            int s2 = size * 32;\n"
            + "            int index2 = tmmalloc_sizeClassRoundUp(s2);\n"
            + "            uint64_t* xx = (uint64_t*) tmmalloc_larger(s2, index2);\n"
            + "            if (xx != 0) {\n"
            + "                tmmalloc_arenaStart = xx - 1;\n"
            + "                tmmalloc_arenaRemaining = tmmalloc_arenaStart[0] >> 1;\n"
            + "                ASSERT((tmmalloc_arenaStart[0] & 1) == 0);\n"
            + "                ASSERT(tmmalloc_arenaStart[0] >> 32 == 0);\n"
            + "            }\n"
            + "        }\n"
            + "        if (tmmalloc_arenaRemaining >= size ) {\n"
            + "            uint64_t* result = tmmalloc_arenaStart;\n"
            + "            // prev may be free already        \n"
            + "            uint64_t old = tmmalloc_arenaStart[0] >> 32 << 32;\n"
            + "            if (tmmalloc_arenaRemaining - size >= 3) {\n"
            + "                tmmalloc_arenaStart[0] = old | (size << 1);\n"
            + "                tmmalloc_arenaRemaining -= size;\n"
            + "                tmmalloc_arenaStart += size;\n"
            + "                tmmalloc_arenaStart[0] = tmmalloc_arenaRemaining << 1;\n"
            + "            } else {\n"
            + "                tmmalloc_arenaStart[0] = old | (tmmalloc_arenaRemaining << 1);\n"
            + "                tmmalloc_arenaRemaining = 0;\n"
            + "            }\n"
            + "            return result + 1;\n"
            + "        }\n"
            + "    }\n"
            + "    return tmmalloc_larger(size, index0);\n"
            + "}\n"
            + "void* tmmalloc_larger(int size, int index0) {\n"
            + "    uint64_t mask = tmmalloc_levelBitmap & (~0ULL << index0);\n"
            + "    int index = __builtin_ctzll(mask);\n"
            + "    if (index >= 64) {\n"
            + "        tmmalloc_addMemory();\n"
            + "        mask = tmmalloc_levelBitmap & (~0ULL << index0);\n"
            + "        index = __builtin_ctzll(mask);\n"
            + "        if (index >= 64) {\n"
            + "            printf(\"Out of memory trying to allocate %d; levels %llx\\n\", size, tmmalloc_levelBitmap) ; \n"
            + "            exit(0);\n"
            + "            return 0;\n"
            + "        }\n"
            + "    }\n"
            + "    uint64_t* block = ((uint64_t*) tmmalloc_data[2 * index]) - 1;\n"
            + "    uint64_t currentSize = block[0] >> 1;\n"
            + "    ASSERT((block[0] & 1) == 1);\n"
            + "    tmmalloc_removeFromFreeBlocksMap(block, index);\n"
            + "    ASSERT(block[0] >> 32 == 0);\n"
            + "    if (currentSize >= size + 3) {\n"
            + "        uint64_t* remaining = block + size;\n"
            + "        uint64_t remainingSize = currentSize - size;\n"
            + "        block[currentSize] &= (1L << 32) - 1;\n"
            + "        block[currentSize] |= remainingSize << 32;\n"
            + "        ASSERT((block[currentSize] & 1) == 0);\n"
            + "        ASSERT(block[currentSize] >> 32 != 0);\n"
            + "        tmmalloc_insertIntoFreeBlocksMap(remaining, remainingSize);\n"
            + "        block[0] = size << 1;\n"
            + "        ASSERT(block[size] >> 32 == 0);\n"
            + "    } else {\n"
            + "        block[currentSize] &= (1L << 32) - 1;\n"
            + "        block[0] = currentSize << 1;\n"
            + "        ASSERT((block[currentSize] & 1) == 0);\n"
            + "        ASSERT(block[currentSize] >> 32 == 0);\n"
            + "    }\n"
            + "    return block + 1;\n"
            + "}\n"
            + "void tmfree(void* ptr) {\n"
            + "    if (ptr == 0) return;\n"
            + "    uint64_t* block = (uint64_t*) ptr;\n"
            + "    block -= 1;    \n"
            + "    uint64_t header = block[0];\n"
            + "    ASSERT((block[0] & 1) == 0);\n"
            + "    uint64_t size = (((1L << 32) - 1) & header) >> 1;\n"
            + "    int prevSize = header >> 32;\n"
            + "    uint64_t* next = block + size;\n"
            + "    int nextSize = next[0] & ((1L << 32) - 1);\n"
            + "    if ((nextSize & 1) == 1) {\n"
            + "        nextSize >>= 1;\n"
            + "        int index = tmmalloc_sizeClass(nextSize);\n"
            + "        tmmalloc_removeFromFreeBlocksMap(next, index);\n"
            + "        size += nextSize;\n"
            + "    }\n"
            + "    if (prevSize) {\n"
            + "        uint64_t* prev = block - prevSize;\n"
            + "        int index = tmmalloc_sizeClass(prevSize);\n"
            + "        ASSERT((prev[0] & 1) == 1);\n"
            + "        tmmalloc_removeFromFreeBlocksMap(prev, index);\n"
            + "        size += prevSize;\n"
            + "        block = prev;\n"
            + "    }\n"
            + "    block[size] &= (1L << 32) - 1;\n"
            + "    block[size] |= size << 32;\n"
            + "    ASSERT((block[size] & 1) == 0);\n"
            + "    ASSERT(block[size] >> 32 != 0);\n"
            + "    tmmalloc_insertIntoFreeBlocksMap(block, size);\n"
            + "}\n"
            + "void tmmalloc_removeFromFreeBlocksMap(uint64_t* block, int index) {\n"
            + "    uint64_t* prev = (uint64_t*) block[2];\n"
            + "    uint64_t* next = (uint64_t*) block[1];\n"
            + "    prev[0] = (uint64_t) next;\n"
            + "    next[1] = (uint64_t) prev;\n"
            + "    int head = 2 * index;\n"
            + "    uint64_t a = tmmalloc_data[head];\n"
            + "    uint64_t b = (uint64_t) &tmmalloc_data[head];\n"
            + "    long diff = a - b;\n"
            + "    long mask = ~((diff - 1) >> 63);\n"
            + "    tmmalloc_levelBitmap &= ~(1ULL << index) | mask;\n"
            + "}\n"
            + "// tmmalloc end =============================\n";

}
