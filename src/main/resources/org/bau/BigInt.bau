module org.bau.BigInt

type bigInt
    negative int
    data i32[]

I32_MIN_VALUE : -(1 << 31)
I32_MAX_VALUE : (1 << 32) - 1
INT_MIN_VALUE : -(1 << 63)

fun numberOfLeadingZeros(x int) int
    native(`return x == 0 ? 64 : __builtin_clzll(x);`)
    if x <= 0
        return if(x = 0, 32, 0)
    n := 63
    shift := 32
    while shift > 0
        if x >= 1 << shift
            n -= shift
            x >>= shift
        shift >>= 1
    return n

fun copyOf(a i32[], newLen int) i32[]
    result : i32[newLen]
    copyLen := newLen
    if a.len < newLen
        copyLen = a.len
    native(```
        #include <stdio.h>
        memcpy(result->data, a->data, copyLen * sizeof(int32_t));
        _decUseStack(_t0, i32_array);
        _decUseStack(a, i32_array);
        return result;
        ```)
    i := 0
    while i < newLen and i < a.len
        result[i] = a[i]
        i += 1
    return result

fun copyOfRange(a T[], from int, to int) T[]
    len : to - from
    x : T[len]
    i := 0
    while i + from < to and i < a.len
        x[i] = a[i + from]
        i += 1
    return x

type str
    data i8[]

fun newBigIntShorten(data i32[], negative int) bigInt
    newLen := data.len
    while newLen > 0 and data[newLen - 1] = 0
        newLen -= 1
    if newLen = 0
        negative = 0
    d2 : if(newLen = data.len, data, copyOf(data, newLen))
    result : bigInt(d2)
    result.negative = negative
    return result

# create a new bigInt
fun newBigInt(value int) bigInt
    if value = 0 
        return bigInt(i32[0])
    elif value < 0 
        if value >= I32_MIN_VALUE
            x : bigInt(i32[1])
            x.data[0] = -value
            x.negative = 1
            return x
        elif value > INT_MIN_VALUE 
            x : bigInt(i32[2])
            x.data[0] = -value
            x.data[1] = -value >> 32
            x.negative = 1
            return x
        else 
            x : bigInt(i32[2])
            x.data[0] = 0
            x.data[1] = 0x80000000
            x.negative = 1
            return x
    else 
        if value <= I32_MAX_VALUE
            x : bigInt(i32[1])
            x.data[0] = value
            return x
        else
            x : bigInt(i32[2])
            x.data[0] = value
            x.data[1] = value >> 32 
            return x

# negate
fun bigInt negate() bigInt
    if data.len = 0
        return this
    x : bigInt(data)
    x.negative = not negative
    return x

# left shift
fun bigInt shiftLeft(n int) bigInt
    if data.len = 0
        return newBigInt(0)
    len : len()
    len2 := len + n
    data2 : i32[(len2 + 31) / 32]
    carry := 0
    i := 0
    while i < len
        old := data[i >> 5] & 0xffffffff
        data2[(i + n) >> 5] = i32((old << (n & 31)) | carry)
        carry = old >> (32 - (n & 31))
        i += 32
    data2[data2.len - 1] |= carry
    return newBigIntShorten(data2, negative)

# length in bits
fun bigInt len() int
    if data.len = 0
        return 0
    lastLen := 64 - numberOfLeadingZeros(data[data.len - 1] & 0xffffffff)
    return (data.len - 1) * 32 + lastLen

fun if(cond int, a T, b T) macro T
    if cond
        return a
    else
        return b

# compare to another value
fun bigInt compareTo(o bigInt) int
    if negative <> o.negative
        return if(negative, -1, 1)
    if negative
        return - negate().compareTo(o.negate())
    len : len()
    oLen : o.len()
    if len <> oLen
        return if(len > oLen, 1, -1)
    i := data.len - 1
    while i >= 0
        x : data[i] & 0xffffffff
        y : o.data[i] & 0xffffffff
        if x <> y
            return if(x > y, 1, -1)
        i -= 1
    return 0

# addition
fun bigInt add(other bigInt) bigInt
    if data.len = 0
        return other
    elif other.data.len = 0
        return this
    if negative
        if other.negative
            return add(data, other.data).negate()
        return negate().subtract(other).negate()
    if other.negative
        return subtract(other.negate())
    return add(data, other.data)

fun add(a i32[], b i32[]) bigInt
    if a.len < b.len
        return add(b, a)
    result : copyOf(a, a.len)
    carry := 0
    for i := until(a.len)
        x : result[i] & 0xffffffff
        y : if(i >= b.len, 0, b[i] & 0xffffffff)
        z : x + y + carry
        result[i] = i32(z)
        carry = z >> 32
    if carry = 0
        return bigInt(result)
    r2 : copyOf(result, result.len + 1)
    r2[r2.len - 1] = 1
    return bigInt(r2)

# subtraction
fun bigInt subtract(other bigInt) bigInt
    if data.len = 0
        return other.negate()
    elif other.data.len = 0
        return this
    if negative
        if not other.negative
            return negate().add(other).negate()
        return negate().subtract(other.negate()).negate()
    if other.negative
        return add(other.negate())
    if compareTo(other) < 0
        return other.subtract(this).negate()
    return subtract(data, other.data)

fun subtract(a i32[], b i32[]) bigInt
    result : copyOf(a, a.len)
    carry := 0
    for i := until(a.len)
        x : result[i] & 0xffffffff
        y := 0
        if i < b.len
            y = b[i] & 0xffffffff
        z : x - y - carry
        carry = (z >> 63) & 1
        result[i] = i32(z)
    return newBigIntShorten(result, 0)

# get the int value (at most 32 bits)
fun bigInt intValue() int
    return signum() * if(data.len = 0, 0, data[0] & 0xffffffff)

# multiplication
fun bigInt multiply(other bigInt) bigInt
    thisLen : len()
    otherLen : other.len()
    if thisLen = 0
        return this
    elif otherLen = 0
        return other
    if negative <> other.negative
        return multiply(other.negate()).negate()
    if thisLen > otherLen
        return other.multiply(this)
    elif thisLen = 1
        # multiply by 1 / -1
        if negative
            return other.negate()
        return other
    return multiply(data, other.data)

# multiply by an integer
fun bigInt multiplyInt(value int) bigInt
    if (value >= 1 << 31 or value <= -(1 << 31))
        return multiply(newBigInt(value))
    other := i32(value)
    thisLen : len()
    if thisLen = 0
        return this
    elif other = 0
        return newBigInt(other)
    otherNegative : other < 0
    if negative <> otherNegative
        return multiplyInt(-other).negate()
    elif thisLen = 1
        # multiply by 1 / -1
        if negative
            return newBigInt(-other)
        return newBigInt(other)
    if otherNegative
        other = -other
    return multiplySmall(other, data)

fun multiply(a i32[], b i32[]) bigInt
    if a.len < b.len
        return multiply(b, a)
    # now a.len >= b.len
    return multiplyBig(a, b)

fun multiplySmall(a i32, b i32[]) bigInt
    if a = 1
        return bigInt(b)
    result : copyOf(b, b.len + 1)
    ax := a & 0xffffffff
    carry := 0
    for i := until(result.len)
        bx : result[i] & 0xffffffff
        z : ax * bx + carry
        result[i] = i32(z)
        carry = z >> 32
    return newBigIntShorten(result, 0)

fun multiplyBig(a i32[], b i32[]) bigInt
    if a.len = 1
        return multiplySmall(a[0], b)
    elif b.len = 1
        return multiplySmall(b[0], a)
    result : i32[a.len + b.len]
    for ai := until(a.len)
        ax : a[ai] & 0xffffffff
        carry := 0
        i := i32(ai)
        for bi := until(b.len)
            bx : b[bi] & 0xffffffff
            z : ax * bx + (result[i] & 0xffffffff) + carry
            result[i] = i32(z)
            carry = z >> 32
            i += 1
        while carry > 0
            z : result[i] + carry
            result[i] = i32(z)
            carry = z >> 32
            i += 1
    return newBigIntShorten(result, 0)

# division
fun bigInt divide(other bigInt) bigInt
    if other.data.len = 0
        # TODO division by zero: currently we return 0
        #Â throw exception instead?
        return newBigInt(0)
    elif negative <> other.negative
        return divide(other.negate()).negate()
    elif negative
        return negate().divide(other.negate())
    cmp : compareTo(other)
    if cmp < 0
        return newBigInt(0)
    elif cmp = 0
        return newBigInt(1)
    remainder := this
    result := newBigInt(0)
    shifted := other
    shiftCount := 0
    shiftedLen : shifted.len()
    len : remainder.len()
    if len - shiftedLen > 1
        shifted = shifted.shiftLeft(len - shiftedLen - 1)
        shiftCount = len - shiftedLen - 1
    while remainder.compareTo(other) >= 0
        result = result.add(newBigInt(1).shiftLeft(shiftCount))
        remainder = remainder.subtract(shifted)
        while shiftCount > 0 and shifted.compareTo(remainder) >= 0
            shifted = shifted.shiftRight(1)
            shiftCount -= 1
    return result

# right shift
fun bigInt shiftRight(n int) bigInt
    len2 : len() - n
    if len2 <= 0
        return newBigInt(0)
    data2 : copyOfRange(data, n / 32, data.len)
    carry := 0
    i := data2.len - 1
    while i >= 0
        x : data2[i] & 0xffffffff
        data2[i] = i32((carry | x) >> (n & 31))
        carry = x << 32
        i -= 1
    return newBigIntShorten(data2, negative)

fun intToStr(n int, buff i8[], start int, size int) int
    i := 0
    while i < size
        buff[start + i] = ord('0') + (n % 10)
        n /= 10
        i += 1
    return i + start

# convert to string
fun bigInt toStr() i8[]
    n := this
    buff := str(i8[50])
    start := 0
    if negative
        buff.data[0] = ord('-')
        start = 1
        n = n.negate()
    i := start
    group := newBigInt(1_000_000_000)
    while
        next := n.divide(group)
        remainder := n.subtract(next.multiply(group))
        val : remainder.intValue()
        if i + 9 >= buff.data.len
            buff = str(copyOfRange(buff.data, 0, buff.data.len * 2))
        i = intToStr(val, buff.data, i, 9)
        n = next
        break n.signum() = 0
    while i > start + 1 and buff.data[i - 1] = ord('0')
        i -= 1
    end : i
    while i > start
        i -= 1
        temp : buff.data[i]
        buff.data[i] = buff.data[start]
        buff.data[start] = temp
        start += 1
    return copyOfRange(buff.data, 0, end)

# get the signum
fun bigInt signum() int
    if data.len = 0
        return 0
    elif negative
        return -1
    return 1
