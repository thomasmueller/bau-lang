module org.bau.BigInt

import org.bau.Utils
    when
import org.bau.Int
    MIN_I32
    MIN_INT
    MAX_I32
    divUnsignedOr0
    compareUnsigned
    arithmeticRightShift
    numberOfLeadingZeros
    intToStr

type bigInt
    negative int
    data i32[]

fun copyOf(a i32[], newLen int) i32[]
    copyLen := newLen
    if a.len < newLen
        copyLen = a.len
    native(```
        #include <stdio.h>
        i32_array* result1 = _malloc(sizeof(i32_array));
        _traceMalloc(result1);
        result1->len = newLen;
        result1->data = _malloc(sizeof(int32_t) * newLen);
        if (newLen > copyLen) {
            memset(result1->data + copyLen, 0, sizeof(int32_t) * (newLen - copyLen));
        }
        _traceMalloc(result1->data);
        result1->_refCount = 1;
        memcpy(result1->data, a->data, copyLen * sizeof(int32_t));
        _decUseStack(a, i32_array);
        return result1;
        ```)
    result : i32[newLen]
    i := 0
    loop i < newLen and i < a.len
        result[i] = a[i]
        i += 1
    return result

fun copyOfRange(a T[], from int, to int) T[]
    len : to - from
    x : T[len]
    i := 0
    loop i + from < to and i < a.len
        x[i] = a[i + from]
        i += 1
    return x

type str
    data i8[]

fun newBigIntShorten(data i32[], negative int) bigInt
    newLen := data.len
    loop newLen > 0 and data[newLen - 1] = 0
        newLen -= 1
    if newLen = 0
        negative = 0
    d2 : when(newLen = data.len, data, copyOf(data, newLen))
    result : bigInt(d2)
    result.negative = negative
    return result

fun convertIntToBigInt(value int) bigInt
    return newBigInt(value)

# create a new bigInt
fun newBigInt(value int) bigInt
    if value = 0 
        return bigInt(i32[0])
    elif value < 0 
        if value >= MIN_I32 << 1
            x : bigInt(i32[1])
            x.data[0] = -value
            x.negative = 1
            return x
        elif value > MIN_INT 
            x : bigInt(i32[2])
            x.data[0] = -value
            x.data[1] = -value >> 32
            x.negative = 1
            return x
        else 
            x : bigInt(i32[2])
            x.data[0] = 0
            x.data[1] = 0x80000000
            x.negative = 1
            return x
    else 
        if value < 1 << 32
            x : bigInt(i32[1])
            x.data[0] = value
            return x
        else
            x : bigInt(i32[2])
            x.data[0] = value
            x.data[1] = value >> 32 
            return x

# negate
fun bigInt neg() bigInt
    if data.len = 0
        return this
    x : bigInt(data)
    x.negative = not negative
    return x

# left shift
fun bigInt shiftLeft(n int) bigInt
    if n < 0
        return shiftRight(-n)
    if data.len = 0
        return newBigInt(0)
    len : len()
    len2 := len + n
    data2 : i32[(len2 + 31) / 32]
    carry := 0
    i := 0
    loop i < len
        old := data[i >> 5] & 0xffffffff
        data2[(i + n) >> 5] = i32((old << (n & 31)) | carry)
        carry = old >> (32 - (n & 31))
        i += 32
    data2[data2.len - 1] |= carry
    return newBigIntShorten(data2, negative)

# right shift
fun bigInt shiftRight(n int) bigInt
    if n < 0
        return shiftLeft(-n)
    len2 : len() - n
    if len2 <= 0
        return newBigInt(0)
    data2 : copyOfRange(data, n / 32, data.len)
    carry := 0
    i := data2.len - 1
    loop i >= 0
        x : data2[i] & 0xffffffff
        data2[i] = i32((carry | x) >> (n & 31))
        carry = x << 32
        i -= 1
    return newBigIntShorten(data2, negative)

# length in bits
fun bigInt len() int
    if data.len = 0
        return 0
    lastLen := 64 - numberOfLeadingZeros(data[data.len - 1] & 0xffffffff)
    return (data.len - 1) * 32 + lastLen

# compare to another value
fun bigInt compare(o bigInt) int
    if negative <> o.negative
        return when(negative, -1, 1)
    if negative
        return - neg().compare(o.neg())
    len : len()
    oLen : o.len()
    if len <> oLen
        return when(len > oLen, 1, -1)
    i := data.len - 1
    loop i >= 0
        x : data[i] & 0xffffffff
        y : o.data[i] & 0xffffffff
        if x <> y
            return when(x > y, 1, -1)
        i -= 1
    return 0

# addition
fun bigInt add(other bigInt) bigInt
    if data.len = 0
        return other
    elif other.data.len = 0
        return this
    if negative
        if other.negative
            return add(data, other.data).neg()
        return neg().sub(other).neg()
    if other.negative
        return sub(other.neg())
    return add(data, other.data)

fun add(a i32[], b i32[]) bigInt
    if a.len < b.len
        return add(b, a)
    result : copyOf(a, a.len)
    carry := 0
    for i := until(a.len)
        x : result[i] & 0xffffffff
        y : when(i >= b.len, 0, b[i] & 0xffffffff)
        z : x + y + carry
        result[i] = i32(z)
        carry = z >> 32
    if carry = 0
        return bigInt(result)
    r2 : copyOf(result, result.len + 1)
    r2[r2.len - 1] = 1
    return bigInt(r2)

# subion
fun bigInt sub(other bigInt) bigInt
    if data.len = 0
        return other.neg()
    elif other.data.len = 0
        return this
    if negative
        if not other.negative
            return neg().add(other).neg()
        return neg().sub(other.neg()).neg()
    if other.negative
        return add(other.neg())
    if compare(other) < 0
        return other.sub(this).neg()
    return sub(data, other.data)

fun sub(a i32[], b i32[]) bigInt
    result : copyOf(a, a.len)
    carry := 0
    for i := until(a.len)
        x : result[i] & 0xffffffff
        y := 0
        if i < b.len
            y = b[i] & 0xffffffff
        z : x - y - carry
        carry = (z >> 63) & 1
        result[i] = i32(z)
    return newBigIntShorten(result, 0)

# get the int value (at most 32 bits)
fun bigInt toInt() int
    return signum() * when(data.len = 0, 0, data[0] & 0xffffffff)

# multiplication
fun bigInt mul(other bigInt) bigInt
    thisLen : len()
    otherLen : other.len()
    if thisLen = 0
        return this
    elif otherLen = 0
        return other
    if negative <> other.negative
        return mul(other.neg()).neg()
    if thisLen > otherLen
        return other.mul(this)
    elif thisLen = 1
        # mul by 1 / -1
        if negative
            return other.neg()
        return other
    return mul(data, other.data)

# mul by an integer
fun bigInt mulInt(value int) bigInt
    if (value >= 1 << 31 or value <= -(1 << 31))
        return mul(newBigInt(value))
    other := i32(value)
    thisLen : len()
    if thisLen = 0
        return this
    elif other = 0
        return newBigInt(other)
    otherNegative : other < 0
    if negative <> otherNegative
        return mulInt(-other).neg()
    elif thisLen = 1
        # mul by 1 / -1
        if negative
            return newBigInt(-other)
        return newBigInt(other)
    if otherNegative
        other = -other
    return mulSmall(other, data)

fun mul(a i32[], b i32[]) bigInt
    if a.len < b.len
        return mul(b, a)
    # now a.len >= b.len
    return mulBig(a, b)

fun mulSmall(a i32, b i32[]) bigInt
    if a = 1
        return bigInt(b)
    newSize := b.len
    if (b[b.len - 1] | a) >> 16 <> 0
        newSize += 1
    result : copyOf(b, newSize)
    ax := a & 0xffffffff
    carry := 0
    for i := until(result.len)
        bx : result[i] & 0xffffffff
        z : ax * bx + carry
        result[i] = i32(z)
        carry = z >> 32
    if carry
        result[result.len - 1] = carry
    return newBigIntShorten(result, 0)

fun mulBig(a i32[], b i32[]) bigInt
    if a.len = 1
        return mulSmall(a[0], b)
    elif b.len = 1
        return mulSmall(b[0], a)
    result : i32[a.len + b.len]
    for ai := until(a.len)
        ax : a[ai] & 0xffffffff
        carry := 0
        i := i32(ai)
        for bi := until(b.len)
            bx : b[bi] & 0xffffffff
            z : ax * bx + (result[i] & 0xffffffff) + carry
            result[i] = i32(z)
            carry = z >> 32
            i += 1
        loop carry > 0
            z : result[i] + carry
            result[i] = i32(z)
            carry = z >> 32
            i += 1
    return newBigIntShorten(result, 0)

# division
fun bigInt div(other bigInt) bigInt
    if other.data.len = 0
        # TODO division by zero: currently we return 0
        #Â throw exception instead?
        return newBigInt(0)
    elif negative <> other.negative
        return div(other.neg()).neg()
    elif negative
        return neg().div(other.neg())
    cmp : compare(other)
    if cmp < 0
        return newBigInt(0)
    elif cmp = 0
        return newBigInt(1)
    if data.len > 2 and len() - other.len() < 16
        # optimization for very small results
        x : shiftRight(other.len() - 16).toInt()
        y : other.shiftRight(other.len() - 16).toInt()
        yp1 : y + 1
        ym1 : y - 1
        if y <> 0
            if yp1 <> 0
                if ym1 <> 0
                    z : x / y
                    if z = x / yp1 and z = x / ym1
                        return newBigInt(z)
    otherLen := other.len()
    shift := (31 - otherLen) & 31
    otherLen += shift
    if otherLen < 3 * 32
        shift += 3 * 32
    u : this.shiftLeft(shift).data
    vn : other.shiftLeft(shift).data
    b : 1 << 32
    n : vn.len + 1
    m : u.len + 1
    un : copyOf(u, m)
    q : i32[m - n + 1]
    vn1 : vn[n - 2] & 0xffffffff
    vn2 : vn[n - 3] & 0xffffffff
    j := m - n
    loop j >= 0
        aa : ((un[j + n - 1] & 0xffffffff) * b) + (un[j + n - 2] & 0xffffffff)
        qhat := divUnsignedOr0(aa, vn1)
        rhat := aa - qhat * vn1
        loop
            if qhat < b
                unnn : un[j + n - 3] & 0xffffffff
                break compareUnsigned(qhat * vn2, rhat * b + unnn) <= 0
            qhat -= 1
            rhat += vn1
            break rhat >= b
        carry := 0
        for i := until(n - 1)
            p : qhat * (vn[i] & 0xffffffff)
            t : (un[i + j] & 0xffffffff) - carry - (p & 0xffffffff)
            un[i + j] = int(t)
            carry = (p >> 32) - arithmeticRightShift(t, 32)
        t : (un[j + n - 1] & 0xffffffff) - carry
        un[j + n - 1] = int(t)
        q[j] = int(qhat)
        j -= 1
    return bigInt(q)

# convert to string
fun bigInt toStr() i8[]
    n := this
    buff := str(i8[50])
    start := 0
    if negative
        buff.data[0] = ord('-')
        start = 1
        n = n.neg()
    i := start
    group := newBigInt(1_000_000_000)
    loop
        next := n.div(group)
        remainder := n.sub(next.mul(group))
        val : remainder.toInt()
        if i + 9 >= buff.data.len
            buff = str(copyOfRange(buff.data, 0, buff.data.len * 2))
        i = intToStr(val, buff.data, i, 9)
        n = next
        break n.signum() = 0
    loop i > start + 1 and buff.data[i - 1] = ord('0')
        i -= 1
    end : i
    loop i > start
        i -= 1
        temp : buff.data[i]
        buff.data[i] = buff.data[start]
        buff.data[start] = temp
        start += 1
    return copyOfRange(buff.data, 0, end)

# get the signum
fun bigInt signum() int
    if data.len = 0
        return 0
    elif negative
        return -1
    return 1
